<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StageBox x Matt Robertson – Case Study</title>
    <link rel="stylesheet" href="public/styles/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
</head>

<body>
    <div class="page-wrapper">
        <header class="article-header">
            <div class="header-content">
                <a href="#" class="back-link">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                        stroke-linecap="round" stroke-linejoin="round">
                        <line x1="19" y1="12" x2="5" y2="12"></line>
                        <polyline points="12 19 5 12 12 5"></polyline>
                    </svg>
                    All Articles
                </a>
                <span class="tag">DSP Research</span>
                <h1>Static vs LUT Distortion: A Performance Comparison</h1>
                <p class="subtitle">Managing signal overhead and computational efficiency in digital audio</p>

                <div class="author-meta">
                    <div class="author-avatar"></div>
                    <div class="meta-info">
                        <strong>Richard Anthony Sanchez</strong>
                        <span>•</span>
                        8 min read
                        <span>•</span>
                        January 8, 2026
                    </div>
                </div>
            </div>

            <div class="hero-image-container">
                <!-- Skeleton UI to mimic the software interface -->
                <div class="skeleton-shape"
                    style="top: 5%; left: 5%; width: 90%; height: 90%; background: rgba(255,255,255,0.02); border: 1px solid rgba(255,255,255,0.1);">
                </div>
                <div class="skeleton-shape"
                    style="top: 10%; left: 10%; width: 20%; height: 70%; background: rgba(0, 255, 170, 0.05); border-left: 2px solid var(--accent-green);">
                </div>
                <div class="skeleton-shape"
                    style="top: 20%; right: 15%; width: 40%; height: 30%; background: rgba(255,255,255,0.03);"></div>
                <div class="skeleton-shape"
                    style="bottom: 15%; right: 15%; width: 60px; height: 60px; border-radius: 50%; border: 2px solid var(--accent-coral);">
                </div>
                <div class="skeleton-shape"
                    style="top: 10%; left: 35%; width: 30%; height: 10px; background: rgba(255,255,255,0.1);"></div>
            </div>
        </header>

        <main class="article-body">
            <h2 class="section-title">The Start of Digital Distortion</h2>
            <p>
                Engineers needed to manage signal. They noticed unpredictable behavior when systems overload. After
                trial and error they came to a reasonable conclusion: clipping.
            </p>
            <p>
                Clipping was developed to contain signal within a system's operating range. Now has many different uses.
                Whether that's preserving headroom or distorting guitar tones, we can find clipping everywhere.
            </p>
            <p>If clipping can be used in differently then what is it?</p>

            <h2 class="section-title">What is clipping?</h2>
            <p>
                Clipping, saturation, and distortion: there's many different names but all of these do the same thing —
                flattens peaks and creates harmonic overtones as a result.
            </p>
            <p>A peak is the max amplitude (highest volume) of a signal. This peak is flattened when distortion is
                applied.</p>

            <div class="body-skeleton" style="height: 200px;">
                <div class="skeleton-shape" style="width: 80%; height: 2px; background: rgba(255,255,255,0.1);"></div>
                <div class="skeleton-shape"
                    style="width: 80%; height: 60px; background: transparent; border: 2px dashed var(--accent-coral); border-radius: 4px;">
                </div>
            </div>
            <p class="skeleton-caption">Comparison between pure sine wave and its distorted counterpart</p>

            <p>A harmonic comparison can also be made:</p>

            <div class="body-skeleton" style="height: 150px;">
                <div class="skeleton-shape"
                    style="bottom: 10px; left: 50%; width: 4px; height: 100px; background: var(--accent-green);"></div>
            </div>
            <p class="skeleton-caption">Here's how a 1khz sine wave looks on FFT</p>

            <div class="body-skeleton" style="height: 150px;">
                <div class="skeleton-shape"
                    style="bottom: 10px; left: 50%; width: 4px; height: 100px; background: var(--accent-coral);"></div>
                <div class="skeleton-shape"
                    style="bottom: 10px; left: 60%; width: 4px; height: 60px; background: var(--accent-coral); opacity: 0.5;">
                </div>
                <div class="skeleton-shape"
                    style="bottom: 10px; left: 70%; width: 4px; height: 40px; background: var(--accent-coral); opacity: 0.3;">
                </div>
            </div>
            <p class="skeleton-caption">The same 1khz sine wave with distortion adds harmonic content</p>

            <p>These two approaches that confirm clipping is happening.</p>

            <h2 class="section-title">Implementing Distortion in DSP</h2>
            <p>
                We can think of digital audio as snapshots of sound over regular time intervals. These are called
                samples.
                Much like movie is a series of pictures that imply motion, samples imply a continuous sound when played
                back in sequence.
            </p>

            <div class="body-skeleton" style="height: 120px; flex-direction: row; gap: 8px;">
                <div class="skeleton-shape" style="width: 8px; height: 40px; background: var(--accent-coral);"></div>
                <div class="skeleton-shape" style="width: 8px; height: 70px; background: var(--accent-coral);"></div>
                <div class="skeleton-shape" style="width: 8px; height: 90px; background: var(--accent-coral);"></div>
                <div class="skeleton-shape" style="width: 8px; height: 60px; background: var(--accent-coral);"></div>
            </div>
            <p class="skeleton-caption">A series of samples capturing a signal at regular intervals</p>

            <p>
                We use mathematical mapping to each of these samples based on its input amplitude. The smoothness of our
                clipping comes from which mathematical mapping approach we use.
            </p>
            <p>
                We can confirm mapping is happening. I'm using a script that counts each sample being processed per
                second then measuring the results.
            </p>

            <pre><code>@init
last_time = time_precise(); // Initialize system clock
sample_counter = 0;         // Current running count
samples_last_second = 0;    // This will show our "Results"

@sample
current_time = time_precise();
(current_time - last_time >= 1.0) ? (
  samples_last_second = sample_counter; // Snapshot the count
  sample_counter = 0;                   // Reset for next second
  last_time = current_time;             // Update reference time
);</code></pre>

            <p>Here's my results</p>

            <div class="body-skeleton" style="height: 100px;">
                <code style="font-size: 1.5rem;">44100 Hz</code>
            </div>
            <p class="skeleton-caption">This session is set to 44.1khz sample rate and the logs confirm each sample is
                processed.</p>

            <h2 class="section-title">The Problem with Wave Shaping Each Sample</h2>
            <p>
                In CD quality audio there are 44,100 samples happening every second. If procedures are happening on each
                sample, that's the same amount of computations per second as our the rate of our samples.
            </p>
            <p>
                The more steps in our algorithm, the more taxing this is on our system.
                Audio developers looked for new solutions. Eventually they came across Look Up Tables.
            </p>

            <h2 class="section-title">LUTs</h2>
            <p>
                Look up tables are a set of instructions that take raw input values and transforms them to desired
                values.
                The primary advantage is we have control over how many desired values we're mapping to per second.
            </p>
            <p>
                Instead of being forced into performing tanh 44,100 times per second we can reduce this by implemented
                fixed destinations for each sample.
                Any reduction in locations a sample can be transformed to should increase overall performance. There is
                no way to know for sure without testing.
            </p>

            <h3 class="section-title" style="font-size: 1.8rem;">Testing Performance: A comparison between LUT and Tanh
            </h3>
            <p>
                It's important to note - these changes can results in microscopic behavior. Since I don't have tools
                that get granular I'll have to artificially increase load. I'll be using a loop condition that will
                emulate 50 instances of each implementation. This will help make changes noticeable for this
                demonstration.
            </p>

            <h4 class="section-title" style="font-size: 1.5rem;">Simple LUT</h4>
            <p>
                This is effectively the resolution of our shape. The higher the points, the closer we can capture the
                detail of our ideal shape.
                But perfection isn't possible due hardware limitations so we'll need to manage our table size
                accordingly.
            </p>
            <p>For our comparison we have two options:</p>
            <ol style="margin-bottom: 24px; padding-left: 20px; color: #cecece;">
                <li style="margin-bottom: 12px;">a distortion that triggers a tanh operation every sample which results
                    in a smooth shape (The smoothness is determined by our sample rate)</li>
                <li style="margin-bottom: 12px;">a distortion that maps each sample to a desired location (The
                    smoothness is determined by table size)</li>
            </ol>

            <div class="chart-container">
                <div class=" ">
                    <h3 class=" ">LUT Distortion (Discrete)</h3>
                    <div class="chart-controls">
                        <div class="control-group">
                            <div class="control-label">
                                Drive
                                <span class="control-value" id="driveVal">1.0</span>
                            </div>
                            <input id="drive" type="range" min="0" max="10" step="0.1" value="1">
                        </div>
                        <div class="control-group">
                            <div class="control-label">
                                Samples
                                <span class="control-value" id="sampleVal">16</span>
                            </div>
                            <input id="samples" type="range" min="4" max="24" step="1" value="16">
                        </div>
                    </div>
                </div>
                <svg id="chart"></svg>
            </div>

            <p>
                The table size in this example is 1024 points. The simple LUT out-performs the tanh implementation
                because less instructions are happening per sample. However this is a tradeoff we're exchanging
                fidelity for performance.
            </p>
            <p>
                But what if we could get closer without increasing our table size? This is where interpolation comes in.
            </p>

            <h4 class="section-title" style="font-size: 1.5rem;">LUT (with interpolation)</h4>
            <p>
                Interpolation is the process of estimating unknown values that fall between known data points,
                essentially filling in the gaps by assuming a pattern or trend.
            </p>

            <blockquote>
                we use data buffer for LUT and get performance increases <a href="#">audio prgrammer</a>
            </blockquote>

            <p>
                If you've ever used keyframes within a video editor, you're already familiar with this concept. Instead
                of animating every frame, motion is assumed based on surrounding keyframes.
                The points on our table have effectively become keyframes - when a sample's amplitude doesn't match a
                desired point, it is averaged between it's two neighboring values.
            </p>

            <h4 class="section-title" style="font-size: 1.5rem;">LUT (with interpolation reduced table size)</h4>
            <p>I reduced table size to 512 from 1024. The CPU performance is now neck-and-neck. Remember: smaller table
                size means lower resolution.</p>

            <div class="chart-container">
                <div class=" ">
                    <h3 class=" ">Static Waveshaper (Index-Spaced)</h3>
                    <div class="chart-controls">
                        <div class="control-group">
                            <div class="control-label">
                                Drive
                                <span class="control-value" id="driveValStatic">1.0</span>
                            </div>
                            <input id="driveStatic" type="range" min="0" max="10" step="0.1" value="1">
                        </div>
                        <div class="control-group">
                            <div class="control-label">
                                Samples
                                <span class="control-value" id="sampleValStatic">64</span>
                            </div>
                            <input id="samplesStatic" type="range" min="4" max="256" step="1" value="64">
                        </div>
                    </div>
                </div>
                <svg id="chartStatic"></svg>
            </div>

            <p><em>LUTs help us achieve a similar shape as math operations but lets us control how much we're spending
                    to
                    get there. Albeit with tradeoff in resolution.</em></p>

            <h2 class="section-title">Harmonic Comparison</h2>
            <p>Our frequency response changed by reducing our LUT table to 4 points. Red line is tanh and yellow is our
                4 point LUT. This results in higher frequency overtones added. In my case, above 10khz.</p>

            <h2 class="section-title">64 vs tanh</h2>
            <p>A 64 point LUT implementation has an indistinguishable frequency response from our tanh implementation.
            </p>

            <h3 class="section-title" style="font-size: 1.8rem;">Indistinguishable overlap</h3>
            <div class="body-skeleton" style="height: 180px;">
                <div class="skeleton-shape"
                    style="width: 80%; height: 2px; background: var(--accent-coral); box-shadow: 0 0 10px var(--accent-coral);">
                </div>
            </div>
            <p class="skeleton-caption">I had to offset the values because the overlap is near perfect</p>

            <h2 class="section-title">Why Aren't We Using LUTs Exclusively?</h2>
            <p>
                Because LUTs give people freedom to choose instructions per second, they can ultimately add more
                overhead than math operations per sample approach.
                Even after reducing our table size to 64 points the performance is still roughly the same as tanh.
            </p>
            <p>
                This is surprisingly common. A LUT often doesn't just map each sample. It also interpolates between
                desired values. This adds more operations per sample which sacrifices performance.
            </p>

            <h3 class="section-title">Conclusion</h3>
            <p>
                A LUT <strong>replaces one expensive nonlinear function</strong>, but it <strong>adds several other
                    operations per sample</strong>. LUT does <strong>not eliminate per-sample processing</strong>, it
                just changes <em>what kind</em>.
            </p>

            <p style="margin-top: 60px;"><strong>References:</strong></p>
            <p>I recommend adding a table size slider on each one of your LUT implementations while debugging. You'll
                quickly find out if using a LUT is worth the tradeoffs outline in this article.</p>
            <p>If you want to test for yourself the source code is here: <a href="#"
                    style="color: var(--accent-coral);">github.com/RichardAnthonySanchez/static-vs-lut</a></p>
        </main>
    </div>

    <script src="public/scripts/main.js"></script>
</body>

</html>